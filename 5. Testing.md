# Testing The Smart Contract

Testing the Smart Contract is basically testing the functions of the Solidity Smart Contract by giving it random values and calling them using the Mocha module we imported and JavaScript. Of course, our life would be much simpler if we test it on Remix IDE, but, (...)

First, we have to create a folder in the main directory/folder (MyFirstSmartContract). The folder will be called ```test``` and inside of it, create a file and call it ```Name.test.js```.  

AS we were doing before, we are going to copy and paste the following code into the file and then learn what each line of code means and does:  

```
const assert = require('assert');
const ganache = require('ganache-cli');
const Web3 = require('web3');
const web3 = new Web3(ganache.provider());

// evm: bytecode
const { abi, evm } = require('../compile');
```  

As you can see in the last line of code, we are going to use the ABI and the Bytecode(EVM) we got from the Contract compilation we did in the ```compile.js``` file. Also, in the first couple of lines, we import the assert library that we will use to test the Smart Contract in the near future. In addition, we now import the ```ganache-cli```, our local Ethereum Test Network. Also, we will require ```Web3```. Web3 is upper case because it is a constructor function which will let us create ```web3``` instances to use.  

Of course, we will be working on one ```web3``` instance at a time. ```web3``` always expects you to provide it with a provider so that it can connect to the ```ganache``` test network.  

Now, you need to add these lines of codes that will resemble the whole testing process:  

```
let accounts;
let name;

beforeEach(async () => {
    // Get a list of all accounts
    accounts = await web3.eth.getAccounts();
    name = await new web3.eth.Contract(abi)
      .deploy({
        data: evm.bytecode.object,
      })
      .send({ from: accounts[0], gas: '1000000' });
});


describe('Name', () => {
    it('deploys a contract', () => {
      assert.ok(name.options.address);
    });
    it('can change then get the name', async () => {
        await name.methods.setName('sharbel').send({ from: accounts[0] });
        const _name = await name.methods.getName().call();
        assert.equal(_name, 'sharbel');
      });
});
```  

At first, created the variables ```accounts``` and ```name``` in order to instantiate them in the ```beforeEach``` method.  

Let us take a step back, In order to test, we are going to use the ```mocha``` module which lets us use those ```it``` methods we see above. Mocha will also gives us access to the ```beforeEach``` and ```describe``` methods.  

First, to test, we need 2 methods: ```beforeEach``` and ```describe```. The ```describe``` method will contain all the tests we want to make on our Smart Contract. However, the statements that we find are common in all tests, are put in the ```beforeEach``` method, acting like a constructor.  

So first, we will deploy an instance of our contract, manipulate it by giving it values, then make assertions about the contract to make sure it is working well.  

We need an external account to deploy this contract, and this is how ganache-cli gets to work. Ganache will provide us with accounts to test with (accounts will be unlocked so we do not need private and public keys to access them). We will use web3 to access those accounts.  

So in the beforeEach method, we will instatiate the account variable. We will use the ```web3``` instance then the Ethereum ```eth``` module to get all the accounts, therefore the ```web3.eth.getAccounts()``` line.  

The, we will use the ```web3.eth``` instance again to create a ```new``` contract and provide it with the ABI (collection of variables and methods we want). We will also deploy it by providing it with the ```bytecode```. Then to send it to the blockchain, we will use the first account (accounts[0]) and choose the gas value of the transaction to be 1000000 gas.
